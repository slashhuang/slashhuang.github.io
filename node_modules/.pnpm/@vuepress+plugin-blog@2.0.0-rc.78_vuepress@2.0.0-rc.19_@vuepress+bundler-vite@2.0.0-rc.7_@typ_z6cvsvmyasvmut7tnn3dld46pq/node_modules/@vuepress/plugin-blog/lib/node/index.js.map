{"version":3,"file":"index.js","sources":["../../src/node/logger.ts","../../src/node/utils.ts","../../src/node/category/getCategory.ts","../../src/node/category/getCategoryOptions.ts","../../src/node/category/prepareCategoriesMap.ts","../../src/node/getPagesMap.ts","../../src/node/store.ts","../../src/node/type/getType.ts","../../src/node/type/getTypeOptions.ts","../../src/node/type/prepareTypesMap.ts","../../src/node/blogPlugin.ts"],"sourcesContent":["import { Logger } from '@vuepress/helper'\n\nexport const PLUGIN_NAME = '@vuepress/plugin-blog'\n\nexport const logger = new Logger(PLUGIN_NAME)\n","import { sanitizeFileName } from 'vuepress/utils'\n\nexport const getPagePath = (path: string): string =>\n  encodeURI(path.split('/').map(sanitizeFileName).join('/'))\n","import {\n  fromEntries,\n  isFunction,\n  isString,\n  removeLeadingSlash,\n} from '@vuepress/helper'\nimport type { Page, PageOptions } from 'vuepress/core'\nimport { colors } from 'vuepress/utils'\nimport type { CategoriesMap, CategoryMap } from '../../shared/index.js'\nimport type { PagesMap } from '../getPagesMap.js'\nimport { logger } from '../logger.js'\nimport type { BlogCategoryOptions } from '../options.js'\nimport type { Store } from '../store.js'\nimport { getPagePath } from '../utils.js'\n\n/**\n * @returns Page paths to be generated\n */\nexport const getCategory = (\n  pagesMap: PagesMap,\n  store: Store,\n  categoryOptions: BlogCategoryOptions[],\n  slugify: (name: string) => string,\n  isDebug: boolean,\n): {\n  categoriesMap: CategoriesMap\n  pageOptions: PageOptions[]\n} => {\n  const result = categoryOptions.map(\n    ({\n      key,\n      getter,\n      sorter = (): number => -1,\n      path = '/:key/',\n      layout = 'Layout',\n      frontmatter = (): Record<string, string> => ({}),\n      itemPath: itemPathOptions = '/:key/:name/',\n      itemLayout = 'Layout',\n      itemFrontmatter = (): Record<string, string> => ({}),\n    }) => {\n      if (isDebug) logger.info(`Generating ${colors.cyan(key)} category.\\n`)\n\n      const getItemPath = isFunction(itemPathOptions)\n        ? itemPathOptions\n        : isString(itemPathOptions)\n          ? (name: string): string =>\n              itemPathOptions\n                .replace(/:key/g, slugify(key))\n                .replace(/:name/g, slugify(name))\n          : (): null => null\n\n      const categoryMap: CategoryMap = {}\n      const pageOptions: PageOptions[] = []\n\n      for (const localePath in pagesMap) {\n        if (path) {\n          const pagePath = `${localePath}${removeLeadingSlash(\n            path.replace(/:key/g, slugify(key)),\n          )}`\n\n          pageOptions.push({\n            path: pagePath,\n            frontmatter: {\n              ...frontmatter(localePath),\n              blog: {\n                type: 'category',\n                key,\n              },\n              layout,\n            },\n          })\n\n          categoryMap[localePath] = {\n            path: getPagePath(pagePath),\n            map: {},\n          }\n        } else {\n          categoryMap[localePath] = {\n            path: '',\n            map: {},\n          }\n        }\n\n        const { map } = categoryMap[localePath]\n        const pageMapStore: Record<string, Page[]> = {}\n\n        for (const page of pagesMap[localePath]) {\n          const categories = getter(page)\n\n          for (const category of categories) {\n            if (!(category in map)) {\n              const itemPath = getItemPath(category)\n\n              if (itemPath) {\n                const itemPagePath = `${localePath}${removeLeadingSlash(itemPath)}`\n\n                pageOptions.push({\n                  path: itemPagePath,\n                  frontmatter: {\n                    ...itemFrontmatter(category, localePath),\n                    blog: {\n                      type: 'category',\n                      name: category,\n                      key,\n                    },\n                    layout: itemLayout,\n                  },\n                })\n\n                map[category] = {\n                  path: getPagePath(itemPagePath),\n                  indexes: [],\n                }\n              } else {\n                map[category] = {\n                  path: '',\n                  indexes: [],\n                }\n              }\n\n              pageMapStore[category] = []\n            }\n\n            pageMapStore[category].push(page)\n          }\n        }\n\n        for (const category in pageMapStore)\n          map[category].indexes = store.addItems(\n            pageMapStore[category]\n              .sort(sorter)\n              .map(({ path: pagePath }) => pagePath),\n          )\n\n        if (isDebug) {\n          let infoMessage = `${key} category in locale ${localePath}:\\n`\n\n          for (const category in map) {\n            const { path: categoryPath, indexes: items } = map[category]\n\n            infoMessage += `${category}: found ${items.length} items${\n              categoryPath ? ` in path: ${categoryPath}` : ''\n            }\\n`\n          }\n\n          logger.info(infoMessage)\n        }\n      }\n\n      return {\n        key,\n        categoryMap,\n        pageOptions,\n      }\n    },\n  )\n\n  return {\n    categoriesMap: fromEntries(\n      result.map(({ key, categoryMap }) => [key, categoryMap]),\n    ),\n    pageOptions: result.map(({ pageOptions }) => pageOptions).flat(),\n  }\n}\n","import { isFunction, isString } from '@vuepress/helper'\nimport { colors } from 'vuepress/utils'\nimport { logger } from '../logger.js'\nimport type { BlogCategoryOptions } from '../options.js'\n\nexport const getCategoryOptions = (\n  category: BlogCategoryOptions[],\n): BlogCategoryOptions[] =>\n  category.filter(({ key, getter }, index) => {\n    // check key option\n    if (!isString(key) || !key) {\n      logger.error(\n        `Invalid ${colors.magenta('key')} option ${colors.cyan(\n          key,\n        )} in ${colors.cyan(`category[${index}]`)}`,\n      )\n\n      return false\n    }\n\n    // check getter option\n    if (!isFunction(getter)) {\n      logger.error(\n        `Invalid ${colors.magenta('getter')} option in \"${colors.cyan(\n          `category[${index}]`,\n        )}\", it should be a function!`,\n      )\n\n      return false\n    }\n\n    return true\n  })\n","import type { App } from 'vuepress/core'\nimport type { CategoriesMap } from '../../shared/index.js'\n\nconst HMR_CODE = `\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n  if (__VUE_HMR_RUNTIME__.updateBlogCategory)\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoriesMap);\n}\n\nif (import.meta.hot)\n  import.meta.hot.accept(({ categoriesMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoriesMap);\n  });\n`\n\n/**\n * @returns Page paths to be generated\n */\nexport const prepareCategoriesMap = async (\n  app: App,\n  categoriesMap: CategoriesMap,\n): Promise<void> => {\n  await app.writeTemp(\n    `blog/category.js`,\n    `\\\nexport const categoriesMap = JSON.parse(${JSON.stringify(JSON.stringify(categoriesMap))});\n${app.env.isDev ? HMR_CODE : ''}\n`,\n  )\n}\n","import type { App, Page } from 'vuepress/core'\n\nexport type PagesMap = Record<string, Page[]>\n\nexport const getPageMap = (\n  app: App,\n  filter: (page: Page) => boolean,\n): PagesMap => {\n  const pagesMap: PagesMap = {\n    '/': [],\n    ...Object.fromEntries(\n      Object.keys(app.siteData.locales).map((localePath) => [localePath, []]),\n    ),\n  }\n\n  app.pages\n    .filter(\n      (page) =>\n        filter(page) &&\n        // filter 404\n        page.path.substring(page.pathLocale.length - 1) !== '/404.html',\n    )\n    .forEach((page) => {\n      pagesMap[page.pathLocale].push(page)\n    })\n\n  return pagesMap\n}\n","import type { App } from 'vuepress/core'\n\nexport class Store {\n  public store: string[]\n\n  public constructor() {\n    this.store = []\n  }\n\n  public addItem(item: string): number {\n    const index = this.store.indexOf(item)\n\n    if (index === -1) {\n      this.store.push(item)\n\n      return this.store.length - 1\n    }\n\n    return index\n  }\n\n  public addItems(items: string[]): number[] {\n    return items.map((item) => this.addItem(item))\n  }\n\n  public clearItem(item: string): void {\n    const index = this.store.indexOf(item)\n\n    if (index !== -1) this.store[index] = ''\n  }\n\n  public toJSON(): string {\n    return JSON.stringify(this.store)\n  }\n}\n\nexport const prepareStore = async (app: App, store: Store): Promise<void> => {\n  await app.writeTemp(\n    `blog/store.js`,\n    `\\\nexport const store = JSON.parse(${JSON.stringify(store.toJSON())});\n`,\n  )\n}\n","import { entries, fromEntries, removeLeadingSlash } from '@vuepress/helper'\nimport type { PageOptions } from 'vuepress/core'\nimport { colors } from 'vuepress/utils'\nimport type { TypeMap, TypesMap } from '../../shared/index.js'\nimport type { PagesMap } from '../getPagesMap.js'\nimport { logger } from '../logger.js'\nimport type { BlogTypeOptions } from '../options.js'\nimport type { Store } from '../store.js'\nimport { getPagePath } from '../utils.js'\n\nexport const getType = (\n  pagesMap: PagesMap,\n  store: Store,\n  type: BlogTypeOptions[],\n  slugify: (name: string) => string,\n  isDebug = false,\n): {\n  typesMap: TypesMap\n  pageOptions: PageOptions[]\n} => {\n  const result = type.map(\n    ({\n      key,\n      sorter = (): number => -1,\n      filter = (): boolean => true,\n      path = '/:key/',\n      layout = 'Layout',\n      frontmatter = (): Record<string, string> => ({}),\n    }) => {\n      if (isDebug) logger.info(`Generating ${colors.cyan(key)} type.\\n`)\n\n      const pageOptions: PageOptions[] = []\n      const typeMap: TypeMap = {}\n\n      entries(pagesMap).forEach(([localePath, pages]) => {\n        // get type page path\n        const pagePath = path\n          ? `${localePath}${removeLeadingSlash(\n              path.replace(/:key/g, slugify(key)),\n            )}`\n          : ''\n\n        // get type indexes\n        const indexes = store.addItems(\n          // get page paths\n          pages\n            .filter(filter)\n            .sort(sorter)\n            .map(({ path: itemPagePath }) => itemPagePath),\n        )\n\n        if (pagePath)\n          pageOptions.push({\n            path: pagePath,\n            frontmatter: {\n              ...frontmatter(localePath),\n              blog: {\n                type: 'type',\n                key,\n              },\n              layout,\n            },\n          })\n\n        if (isDebug)\n          logger.info(\n            `${key} type in locale ${localePath}: found ${indexes.length} items\\n`,\n          )\n\n        typeMap[localePath] = { path: getPagePath(pagePath), indexes }\n      })\n\n      return { key, typeMap, pageOptions }\n    },\n  )\n\n  return {\n    typesMap: fromEntries(result.map(({ key, typeMap }) => [key, typeMap])),\n    pageOptions: result.map(({ pageOptions }) => pageOptions).flat(),\n  }\n}\n","import { isString } from '@vuepress/helper'\nimport { colors } from 'vuepress/utils'\nimport { logger } from '../logger.js'\nimport type { BlogTypeOptions } from '../options.js'\n\nexport const getTypeOptions = (types: BlogTypeOptions[]): BlogTypeOptions[] =>\n  types.filter((type, index) => {\n    const { key } = type\n\n    if (!isString(key) || !key) {\n      logger.error(\n        `Invalid ${colors.magenta('key')} option ${colors.cyan(\n          key,\n        )} in ${colors.cyan(`type[${index}]`)}`,\n      )\n\n      return false\n    }\n\n    return true\n  })\n","import type { App } from 'vuepress/core'\nimport type { TypesMap } from '../../shared/index.js'\n\nconst HMR_CODE = `\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n  if (__VUE_HMR_RUNTIME__.updateBlogType)\n    __VUE_HMR_RUNTIME__.updateBlogType(typesMap);\n}\n\nif (import.meta.hot)\n  import.meta.hot.accept(({ typesMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogType(typesMap);\n  });\n`\n\nexport const prepareTypesMap = async (\n  app: App,\n  typesMapData: TypesMap,\n): Promise<void> => {\n  await app.writeTemp(\n    `blog/type.js`,\n    `\\\nexport const typesMap = JSON.parse(${JSON.stringify(JSON.stringify(typesMapData))});\n${app.env.isDev ? HMR_CODE : ''}\n`,\n  )\n}\n","import { addViteSsrNoExternal, getPageExcerpt } from '@vuepress/helper'\nimport { watch } from 'chokidar'\nimport type { Page, PluginFunction } from 'vuepress/core'\nimport {\n  createPage,\n  preparePageChunk,\n  preparePageComponent,\n  prepareRoutes,\n} from 'vuepress/core'\nimport type { CategoriesMap, TypesMap } from '../shared/index.js'\nimport {\n  getCategory,\n  getCategoryOptions,\n  prepareCategoriesMap,\n} from './category/index.js'\nimport { getPageMap } from './getPagesMap.js'\nimport { PLUGIN_NAME, logger } from './logger.js'\nimport type { BlogPluginOptions } from './options.js'\nimport { Store, prepareStore } from './store.js'\nimport { getType, getTypeOptions, prepareTypesMap } from './type/index.js'\n\nexport const blogPlugin =\n  (options: BlogPluginOptions): PluginFunction =>\n  (app) => {\n    if (app.env.isDebug) logger.info('Options:', options)\n\n    const {\n      getInfo = (): Record<string, never> => ({}),\n      filter = (page): boolean =>\n        Boolean(page.filePathRelative) && !page.frontmatter.home,\n      metaScope = '_blog',\n      excerpt = true,\n      excerptSeparator = '<!-- more -->',\n      excerptLength = 300,\n      excerptFilter = filter,\n      isCustomElement = (): boolean => false,\n      category = [],\n      type = [],\n      slugify = (name: string): string =>\n        name\n          .replace(/[ _]/g, '-')\n          .replace(/[:?*|\\\\/<>]/g, '')\n          .toLowerCase(),\n    } = options\n\n    const categoryOptions = getCategoryOptions(category)\n    const typeOptions = getTypeOptions(type)\n    const store = new Store()\n    let blogPagePaths: string[] = []\n    let categoriesMap: CategoriesMap = {}\n    let typesMap: TypesMap = {}\n\n    return {\n      name: PLUGIN_NAME,\n\n      define: () => ({\n        __BLOG_META_SCOPE__: metaScope,\n      }),\n\n      extendsBundlerOptions: (bundlerOptions: unknown): void => {\n        addViteSsrNoExternal(bundlerOptions, app, '@vuepress/helper')\n      },\n\n      extendsPage: (page): void => {\n        // Generate page excerpt\n        if (\n          excerpt &&\n          excerptFilter(page) &&\n          !(page as Page<{ excerpt?: string }>).data.excerpt\n        ) {\n          ;(page as Page<{ excerpt?: string }>).data.excerpt = getPageExcerpt(\n            app,\n            page,\n            {\n              isCustomElement,\n              separator: excerptSeparator,\n              length: excerptLength,\n            },\n          )\n        }\n\n        // inject meta information\n        if (filter(page))\n          page.routeMeta = {\n            ...(metaScope === ''\n              ? getInfo(page)\n              : { [metaScope]: getInfo(page) }),\n            ...page.routeMeta,\n          }\n      },\n\n      onInitialized: async (): Promise<void> => {\n        const pageMap = getPageMap(app, filter)\n\n        const categoryResult = getCategory(\n          pageMap,\n          store,\n          categoryOptions,\n          slugify,\n          app.env.isDebug,\n        )\n\n        const typeResult = getType(\n          pageMap,\n          store,\n          typeOptions,\n          slugify,\n          app.env.isDebug,\n        )\n\n        await Promise.all(\n          [...categoryResult.pageOptions, ...typeResult.pageOptions].map(\n            async (pageOptions) => {\n              const index = app.pages.findIndex(\n                (page) => page.path === pageOptions.path,\n              )\n\n              if (index !== -1) {\n                logger.warn('Overriding existing page:', pageOptions.path)\n\n                const existingIndex = app.pages.findIndex(\n                  (page) => page.path === pageOptions.path,\n                )\n\n                app.pages.splice(\n                  existingIndex,\n                  1,\n                  await createPage(app, pageOptions),\n                )\n              }\n\n              app.pages.push(await createPage(app, pageOptions))\n            },\n          ),\n        )\n\n        // store data for onPrepared and onWatched\n        blogPagePaths = [\n          ...categoryResult.pageOptions,\n          ...typeResult.pageOptions,\n        ].map((page) => page.path!)\n        categoriesMap = categoryResult.categoriesMap\n        typesMap = typeResult.typesMap\n      },\n\n      onPrepared: async (): Promise<void> => {\n        // Prepare store\n        await prepareStore(app, store)\n        // Prepare category\n        await prepareCategoriesMap(app, categoriesMap)\n        // Prepare type\n        await prepareTypesMap(app, typesMap)\n\n        if (app.env.isDebug) logger.info('temp file generated')\n      },\n\n      onWatched: (_, watchers): void => {\n        const hotReload =\n          'hotReload' in options ? options.hotReload : app.env.isDebug\n\n        if (hotReload) {\n          const pageDataWatcher = watch('pages/**/*.js', {\n            cwd: app.dir.temp(),\n            ignoreInitial: true,\n          })\n\n          const updateBlog = async (): Promise<void> => {\n            const pageMap = getPageMap(app, filter)\n            const categoryResult = getCategory(\n              pageMap,\n              store,\n              categoryOptions,\n              slugify,\n              app.env.isDebug,\n            )\n\n            const typeResult = getType(\n              pageMap,\n              store,\n              typeOptions,\n              slugify,\n              app.env.isDebug,\n            )\n\n            const newPageOptions = [\n              ...categoryResult.pageOptions,\n              ...typeResult.pageOptions,\n            ]\n\n            await prepareCategoriesMap(app, categoryResult.categoriesMap)\n            await prepareTypesMap(app, typeResult.typesMap)\n\n            const pagesToBeAdded = newPageOptions.filter(\n              (pageOptions) => !blogPagePaths.includes(pageOptions.path!),\n            )\n            const pagesToBeRemoved = blogPagePaths.filter((path) =>\n              newPageOptions.every((page) => page.path !== path),\n            )\n\n            // add new pages\n            if (pagesToBeAdded.length) {\n              if (app.env.isDebug)\n                logger.info(\n                  `Adding new pages: ${pagesToBeAdded.map(({ path }) => path).join(', ')}`,\n                )\n\n              // Prepare page files\n              await Promise.all(\n                pagesToBeAdded.map(async (pageOptions) => {\n                  const page = await createPage(app, pageOptions)\n\n                  await preparePageComponent(app, page)\n                  await preparePageChunk(app, page)\n                  app.pages.push(page)\n                }),\n              )\n            }\n\n            // Remove pages\n            if (pagesToBeRemoved.length) {\n              if (app.env.isDebug)\n                logger.info(\n                  `Removing following pages: ${pagesToBeRemoved.join(', ')}`,\n                )\n\n              pagesToBeRemoved.forEach((pagePath) => {\n                app.pages.splice(\n                  app.pages.findIndex(({ path }) => path === pagePath),\n                  1,\n                )\n              })\n            }\n\n            // Prepare pages entry\n            if (pagesToBeRemoved.length || pagesToBeAdded.length) {\n              await prepareRoutes(app)\n            }\n\n            // store blog pages for next update\n            blogPagePaths = newPageOptions.map((page) => page.path!)\n\n            if (app.env.isDebug) logger.info('temp file updated')\n          }\n\n          pageDataWatcher.on('add', () => {\n            void updateBlog()\n          })\n          pageDataWatcher.on('change', () => {\n            void updateBlog()\n          })\n          pageDataWatcher.on('unlink', () => {\n            void updateBlog()\n          })\n\n          watchers.push(pageDataWatcher)\n        }\n      },\n    }\n  }\n"],"names":["PLUGIN_NAME","logger","Logger","getPagePath","path","sanitizeFileName","getCategory","pagesMap","store","categoryOptions","slugify","isDebug","result","key","getter","sorter","layout","frontmatter","itemPathOptions","itemLayout","itemFrontmatter","colors","getItemPath","isFunction","isString","name","categoryMap","pageOptions","localePath","pagePath","removeLeadingSlash","map","pageMapStore","page","categories","category","itemPath","itemPagePath","infoMessage","categoryPath","items","fromEntries","getCategoryOptions","index","HMR_CODE","prepareCategoriesMap","app","categoriesMap","getPageMap","filter","Store","item","prepareStore","getType","type","typeMap","entries","pages","indexes","getTypeOptions","types","prepareTypesMap","typesMapData","blogPlugin","options","getInfo","metaScope","excerpt","excerptSeparator","excerptLength","excerptFilter","isCustomElement","typeOptions","blogPagePaths","typesMap","bundlerOptions","addViteSsrNoExternal","getPageExcerpt","pageMap","categoryResult","typeResult","existingIndex","createPage","_","watchers","pageDataWatcher","watch","updateBlog","newPageOptions","pagesToBeAdded","pagesToBeRemoved","preparePageComponent","preparePageChunk","prepareRoutes"],"mappings":"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"}