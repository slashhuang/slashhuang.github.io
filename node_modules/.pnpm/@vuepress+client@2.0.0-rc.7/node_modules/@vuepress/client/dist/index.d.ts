import * as vue from 'vue';
import { Component, ComputedRef, Ref, App, HTMLAttributes, FunctionalComponent, VNode, InjectionKey } from 'vue';
import { PageData, HeadConfig, SiteData, PageFrontmatter } from '@vuepress/shared';
export { HeadConfig, PageData, PageFrontmatter, PageHeader, SiteData } from '@vuepress/shared';
import { Router } from 'vue-router';
export { RouteLocationNormalizedLoaded, Router, useRoute, useRouter } from 'vue-router';
export { C as CreateVueAppFunction } from './createVueAppFunction-YNGNKfE3.js';

/**
 * Name of the default layout
 */
declare const LAYOUT_NAME_DEFAULT = "Layout";
/**
 * Name of the 404 page layout
 */
declare const LAYOUT_NAME_NOT_FOUND = "NotFound";

interface PageChunk {
    comp: Component;
    data: PageData;
}
type RouteMeta = Record<string, unknown>;
interface Route<T extends RouteMeta = RouteMeta> {
    loader: () => Promise<PageChunk>;
    meta: T;
}
type Redirects = Record<string, string>;
type Routes = Record<string, Route>;

interface Layouts {
    [LAYOUT_NAME_DEFAULT]: Component;
    [LAYOUT_NAME_NOT_FOUND]: Component;
    [key: string]: Component;
}
type PageComponent = Component;
type PageHead = HeadConfig[];
type PageHeadTitle = string;
type PageLang = string;
type PageLayout = Component;
type RoutePath = string;
type RouteLocale = string;
type SiteLocaleData = SiteData;
type LayoutsRef = ComputedRef<Layouts>;
type PageComponentRef = ComputedRef<PageComponent>;
type PageDataRef<T extends Record<any, any> = Record<never, never>> = ComputedRef<PageData<T>>;
type PageFrontmatterRef<T extends Record<any, any> = Record<never, never>> = ComputedRef<PageFrontmatter<T>>;
type PageHeadRef = ComputedRef<PageHead>;
type PageHeadTitleRef = ComputedRef<PageHeadTitle>;
type PageLangRef = ComputedRef<PageLang>;
type PageLayoutRef = ComputedRef<PageLayout>;
type RedirectsRef = Ref<Redirects>;
type RoutePathRef = ComputedRef<RoutePath>;
type RouteLocaleRef = ComputedRef<RouteLocale>;
type RoutesRef = Ref<Routes>;
type SiteDataRef = Ref<SiteData>;
type SiteLocaleDataRef = ComputedRef<SiteLocaleData>;
interface ClientData {
    layouts: LayoutsRef;
    pageComponent: PageComponentRef;
    pageData: PageDataRef;
    pageFrontmatter: PageFrontmatterRef;
    pageHead: PageHeadRef;
    pageHeadTitle: PageHeadTitleRef;
    pageLang: PageLangRef;
    pageLayout: PageLayoutRef;
    redirects: RedirectsRef;
    routePath: RoutePathRef;
    routeLocale: RouteLocaleRef;
    routes: RoutesRef;
    siteData: SiteDataRef;
    siteLocaleData: SiteLocaleDataRef;
}

/**
 * Configure vuepress client
 */
interface ClientConfig {
    /**
     * An enhance function to be called after vue app instance and
     * vue-router instance has been created
     */
    enhance?: (context: {
        app: App;
        router: Router;
        siteData: SiteDataRef;
    }) => void | Promise<void>;
    /**
     * A function to be called inside the setup function of vue app
     */
    setup?: () => void;
    /**
     * Layout components
     */
    layouts?: Layouts;
    /**
     * Components to be placed directly into the root node of vue app
     */
    rootComponents?: Component[];
}

/**
 * Wrapper component that only renders its content on the client side and skips server side rendering
 */
declare const ClientOnly: vue.DefineComponent<{}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[] | null | undefined, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{}>>, {}, {}>;

/**
 * Markdown rendered content
 */
declare const Content: vue.DefineComponent<{
    path: {
        type: StringConstructor;
        required: false;
        default: string;
    };
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{
    path: {
        type: StringConstructor;
        required: false;
        default: string;
    };
}>>, {
    path: string;
}, {}>;

interface RouteLinkProps extends HTMLAttributes {
    /**
     * Whether the link is active to have an active class
     *
     * Notice that the active status is not automatically determined according to the current route.
     *
     * @default false
     */
    active?: boolean;
    /**
     * The class to add when the link is active
     *
     * @default 'route-link-active'
     */
    activeClass?: string;
    /**
     * The route path to link to
     */
    to: string;
}
/**
 * Component to render a link to another route.
 *
 * It's similar to `RouterLink` in `vue-router`, but more lightweight.
 *
 * It's recommended to use `RouteLink` in VuePress.
 */
declare const RouteLink: FunctionalComponent<RouteLinkProps, Record<never, never>, {
    default: () => string | VNode | (string | VNode)[];
}>;

/**
 * Injection key for client data
 */
declare const clientDataSymbol: InjectionKey<ClientData>;
/**
 * Returns client data
 */
declare const useClientData: () => ClientData;

declare const useLayouts: () => LayoutsRef;
declare const usePageComponent: () => PageComponentRef;
declare const usePageData: <T extends Record<any, any> = Record<never, never>>() => PageDataRef<T>;
declare const usePageFrontmatter: <T extends Record<any, any> = Record<string, unknown>>() => PageFrontmatterRef<T>;
declare const usePageHead: () => PageHeadRef;
declare const usePageLang: () => PageLangRef;
declare const usePageLayout: () => PageLayoutRef;
declare const useRedirects: () => RedirectsRef;
declare const useRouteLocale: () => RouteLocaleRef;
declare const useRoutePath: () => RoutePathRef;
declare const useRoutes: () => RoutesRef;
declare const useSiteData: () => SiteDataRef;
declare const useSiteLocaleData: () => SiteLocaleDataRef;

/**
 * A util function to force update `<head>` of current page
 */
type UpdateHead = () => void;
/**
 * Injection key for `updateHead` util
 */
declare const updateHeadSymbol: InjectionKey<UpdateHead>;
/**
 * Returns the `updateHead` util
 */
declare const useUpdateHead: () => UpdateHead;

interface ResolvedRoute<T extends RouteMeta = RouteMeta> extends Route<T> {
    path: string;
    notFound: boolean;
}
/**
 * Resolve route with given path
 */
declare const resolveRoute: <T extends RouteMeta = RouteMeta>(path: string) => ResolvedRoute<T>;

/**
 * Resolve route path with given raw path
 */
declare const resolveRoutePath: (path: string) => string;

/**
 * Resolver methods to get global computed
 *
 * Users can override corresponding method for advanced customization
 *
 * @experimental - This is an experimental API and may be changed in minor versions
 */
declare const resolvers: {
    resolveLayouts: (clientConfigs: ClientConfig[]) => Layouts;
    resolvePageHead: (pageHeadTitle: PageHeadTitle, pageFrontmatter: PageFrontmatter, siteLocaleDate: SiteData) => PageHead;
    resolvePageHeadTitle: (pageData: PageData, siteLocaleDate: SiteData) => PageHeadTitle;
    resolvePageLang: (pageData: PageData, siteLocaleData: SiteData) => PageLang;
    resolvePageLayout: (pageData: PageData, layouts: Layouts) => PageLayout;
    resolveRouteLocale: (locales: SiteData['locales'], routePath: string) => RouteLocale;
    resolveSiteLocaleData: (siteData: SiteData, routeLocale: RouteLocale) => SiteLocaleData;
};

/**
 * Prefix url with site base
 */
declare const withBase: (url: string) => string;

export { type ClientConfig, type ClientData, ClientOnly, Content, type Layouts, type LayoutsRef, type PageChunk, type PageComponent, type PageComponentRef, type PageDataRef, type PageFrontmatterRef, type PageHead, type PageHeadRef, type PageHeadTitle, type PageHeadTitleRef, type PageLang, type PageLangRef, type PageLayout, type PageLayoutRef, type Redirects, type RedirectsRef, type Route, RouteLink, type RouteLinkProps, type RouteLocale, type RouteLocaleRef, type RouteMeta, type RoutePath, type RoutePathRef, type Routes, type RoutesRef, type SiteDataRef, type SiteLocaleData, type SiteLocaleDataRef, type UpdateHead, clientDataSymbol, resolveRoute, resolveRoutePath, resolvers, updateHeadSymbol, useClientData, useLayouts, usePageComponent, usePageData, usePageFrontmatter, usePageHead, usePageLang, usePageLayout, useRedirects, useRouteLocale, useRoutePath, useRoutes, useSiteData, useSiteLocaleData, useUpdateHead, withBase };
