import * as vue from 'vue';
import { Component, ComputedRef, Ref, App, PropType, VNode, SlotsType, InjectionKey } from 'vue';
import { PageData, HeadConfig, PageFrontmatter, SiteData, SiteLocaleData } from '@vuepress/shared';
export { HeadConfig, PageData, PageFrontmatter, PageHeader, SiteData, SiteLocaleData } from '@vuepress/shared';
import { Router } from 'vue-router';
export { RouteLocationNormalizedLoaded, Router, useRoute, useRouter } from 'vue-router';
export { C as CreateVueAppFunction } from './createVueAppFunction-onJTVJru.js';

/**
 * Name of the default layout
 */
declare const LAYOUT_NAME_DEFAULT = "Layout";
/**
 * Name of the 404 page layout
 */
declare const LAYOUT_NAME_NOT_FOUND = "NotFound";

interface PageChunk {
    comp: Component;
    data: PageData;
}
type RouteMeta = Record<string, unknown>;
interface Route<T extends RouteMeta = RouteMeta> {
    loader: () => Promise<PageChunk>;
    meta: T;
}
type Redirects = Record<string, string>;
type Routes = Record<string, Route>;

interface Layouts {
    [LAYOUT_NAME_DEFAULT]: Component;
    [LAYOUT_NAME_NOT_FOUND]: Component;
    [key: string]: Component;
}
type PageComponent = Component;
type PageHead = HeadConfig[];
type PageHeadTitle = string;
type PageLang = string;
type PageLayout = Component;
type RoutePath = string;
type RouteLocale = string;
type LayoutsRef = ComputedRef<Layouts>;
type PageComponentRef = ComputedRef<PageComponent>;
type PageDataRef<T extends Record<string, unknown> = Record<string, unknown>> = ComputedRef<PageData<T>>;
type PageFrontmatterRef<T extends Record<string, unknown> = Record<string, unknown>> = ComputedRef<PageFrontmatter<T>>;
type PageHeadRef = ComputedRef<PageHead>;
type PageHeadTitleRef = ComputedRef<PageHeadTitle>;
type PageLangRef = ComputedRef<PageLang>;
type PageLayoutRef = ComputedRef<PageLayout>;
type RedirectsRef = Ref<Redirects>;
type RoutePathRef = ComputedRef<RoutePath>;
type RouteLocaleRef = ComputedRef<RouteLocale>;
type RoutesRef = Ref<Routes>;
type SiteDataRef = Ref<SiteData>;
type SiteLocaleDataRef = ComputedRef<SiteLocaleData>;
interface ClientData {
    layouts: LayoutsRef;
    pageComponent: PageComponentRef;
    pageData: PageDataRef;
    pageFrontmatter: PageFrontmatterRef;
    pageHead: PageHeadRef;
    pageHeadTitle: PageHeadTitleRef;
    pageLang: PageLangRef;
    pageLayout: PageLayoutRef;
    redirects: RedirectsRef;
    routePath: RoutePathRef;
    routeLocale: RouteLocaleRef;
    routes: RoutesRef;
    siteData: SiteDataRef;
    siteLocaleData: SiteLocaleDataRef;
}

/**
 * Configure vuepress client
 */
interface ClientConfig {
    /**
     * An enhance function to be called after vue app instance and
     * vue-router instance has been created
     */
    enhance?: (context: {
        app: App;
        router: Router;
        siteData: SiteDataRef;
    }) => Promise<void> | void;
    /**
     * A function to be called inside the setup function of vue app
     */
    setup?: () => void;
    /**
     * Layout components
     */
    layouts?: Partial<Layouts>;
    /**
     * Components to be placed directly into the root node of vue app
     */
    rootComponents?: Component[];
}

interface AutoLinkConfig {
    /**
     * Pattern to determine if the link should be active, which has higher priority than `exact`
     */
    activeMatch?: RegExp | string;
    /**
     * The `aria-label` attribute
     */
    ariaLabel?: string;
    /**
     * Whether the link should be active only if the url is an exact match
     */
    exact?: boolean;
    /**
     * URL of the auto link
     */
    link: string;
    /**
     * The `rel` attribute
     */
    rel?: string;
    /**
     * The `target` attribute
     */
    target?: string;
    /**
     * Text of the auto link
     */
    text: string;
}
/**
 * Component to render a link automatically according to the link type
 *
 * - If the link is internal, it will be rendered as a `<RouteLink>`
 * - If the link is external, it will be rendered as a normal `<a>` tag
 */
declare const AutoLink: vue.DefineComponent<vue.ExtractPropTypes<{
    config: {
        type: PropType<AutoLinkConfig>;
        required: true;
    };
}>, () => VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{
    config: {
        type: PropType<AutoLinkConfig>;
        required: true;
    };
}>> & Readonly<{}>, {}, SlotsType<{
    default?: (config: AutoLinkConfig) => VNode | VNode[];
    before?: (config: AutoLinkConfig) => VNode | VNode[] | null;
    after?: (config: AutoLinkConfig) => VNode | VNode[] | null;
}>, {}, {}, string, vue.ComponentProvideOptions, true, {}, any>;

/**
 * Wrapper component that only renders its content on the client side and skips server side rendering
 *
 * Since vue 3.5, you can try the new `data-allow-mismatch` attribute instead of `<ClientOnly>` component in some cases to avoid hydration mismatch.
 *
 * @see https://blog.vuejs.org/posts/vue-3-5#data-allow-mismatch
 */
declare const ClientOnly: vue.DefineComponent<{}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[] | null | undefined, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<{}> & Readonly<{}>, {}, {}, {}, {}, string, vue.ComponentProvideOptions, true, {}, any>;

/**
 * Markdown rendered content
 */
declare const Content: vue.DefineComponent<vue.ExtractPropTypes<{
    path: {
        type: StringConstructor;
        required: false;
        default: string;
    };
}>, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{
    path: {
        type: StringConstructor;
        required: false;
        default: string;
    };
}>> & Readonly<{}>, {
    path: string;
}, {}, {}, {}, string, vue.ComponentProvideOptions, true, {}, any>;

interface RouteLinkProps {
    /**
     * Whether the link is active to have an active class
     *
     * Notice that the active status is not automatically determined according to the current route.
     *
     * @default false
     */
    active?: boolean;
    /**
     * The class to add when the link is active
     *
     * @default 'route-link-active'
     */
    activeClass?: string;
    /**
     * The route path to link to
     */
    to: string;
}
/**
 * Component to render a link to another route.
 *
 * It's similar to `RouterLink` in `vue-router`, but more lightweight.
 *
 * It's recommended to use `RouteLink` in VuePress.
 */
declare const RouteLink: vue.DefineComponent<vue.ExtractPropTypes<{
    /**
     * The route path to link to
     */
    to: {
        type: StringConstructor;
        required: true;
    };
    /**
     * Whether the link is active to have an active class
     *
     * Notice that the active status is not automatically determined according to the current route.
     */
    active: BooleanConstructor;
    /**
     * The class to add when the link is active
     */
    activeClass: {
        type: StringConstructor;
        default: string;
    };
}>, () => VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.PublicProps, Readonly<vue.ExtractPropTypes<{
    /**
     * The route path to link to
     */
    to: {
        type: StringConstructor;
        required: true;
    };
    /**
     * Whether the link is active to have an active class
     *
     * Notice that the active status is not automatically determined according to the current route.
     */
    active: BooleanConstructor;
    /**
     * The class to add when the link is active
     */
    activeClass: {
        type: StringConstructor;
        default: string;
    };
}>> & Readonly<{}>, {
    active: boolean;
    activeClass: string;
}, SlotsType<{
    default: () => (VNode | string)[] | VNode | string;
}>, {}, {}, string, vue.ComponentProvideOptions, true, {}, any>;

/**
 * Injection key for client data
 */
declare const clientDataSymbol: InjectionKey<ClientData>;
/**
 * Returns client data
 */
declare const useClientData: () => ClientData;

declare const useLayouts: () => LayoutsRef;
declare const usePageComponent: () => PageComponentRef;
declare const usePageData: <T extends Record<string, unknown> = Record<string, unknown>>() => PageDataRef<T>;
declare const usePageFrontmatter: <T extends Record<string, unknown> = Record<string, unknown>>() => PageFrontmatterRef<T>;
declare const usePageHead: () => PageHeadRef;
declare const usePageLang: () => PageLangRef;
declare const usePageLayout: () => PageLayoutRef;
declare const useRedirects: () => RedirectsRef;
declare const useRouteLocale: () => RouteLocaleRef;
declare const useRoutePath: () => RoutePathRef;
declare const useRoutes: () => RoutesRef;
declare const useSiteData: () => SiteDataRef;
declare const useSiteLocaleData: () => SiteLocaleDataRef;

/**
 * A util function to force update `<head>` of current page
 */
type UpdateHead = () => void;
/**
 * Injection key for `updateHead` util
 */
declare const updateHeadSymbol: InjectionKey<UpdateHead>;
/**
 * Returns the `updateHead` util
 */
declare const useUpdateHead: () => UpdateHead;

interface ResolvedRoute<T extends RouteMeta = RouteMeta> extends Route<T> {
    path: string;
    notFound: boolean;
}
/**
 * Resolve route with given path
 */
declare const resolveRoute: <T extends RouteMeta = RouteMeta>(path: string, currentPath?: string) => ResolvedRoute<T>;

/**
 * Resolve route full path with given raw path
 */
declare const resolveRouteFullPath: (path: string, currentPath?: string) => string;

/**
 * Resolve route path with given raw path
 */
declare const resolveRoutePath: (pathname: string, currentPath?: string) => string;

/**
 * Resolver methods to get global computed
 *
 * Users can override corresponding method for advanced customization
 *
 * @experimental - This is an experimental API and may be changed in minor versions
 */
declare const resolvers: {
    resolveLayouts: (clientConfigs: ClientConfig[]) => Layouts;
    resolvePageHead: (pageHeadTitle: PageHeadTitle, pageFrontmatter: PageFrontmatter, siteLocaleDate: SiteLocaleData) => PageHead;
    resolvePageHeadTitle: (pageData: PageData, siteLocaleDate: SiteLocaleData) => PageHeadTitle;
    resolvePageLang: (pageData: PageData, siteLocaleData: SiteLocaleData) => PageLang;
    resolvePageLayout: (pageData: PageData, layouts: Layouts) => PageLayout;
    resolveRouteLocale: (locales: SiteData["locales"], routePath: string) => RouteLocale;
    resolveSiteLocaleData: ({ base, locales, ...siteData }: SiteData, routeLocale: RouteLocale) => SiteLocaleData;
};

/**
 * A helper function to help you define vuepress client config file
 */
declare const defineClientConfig: (clientConfig?: ClientConfig) => ClientConfig;

/**
 * Prefix url with site base
 */
declare const withBase: (url: string) => string;

export { AutoLink, type AutoLinkConfig, type ClientConfig, type ClientData, ClientOnly, Content, type Layouts, type LayoutsRef, type PageChunk, type PageComponent, type PageComponentRef, type PageDataRef, type PageFrontmatterRef, type PageHead, type PageHeadRef, type PageHeadTitle, type PageHeadTitleRef, type PageLang, type PageLangRef, type PageLayout, type PageLayoutRef, type Redirects, type RedirectsRef, type ResolvedRoute, type Route, RouteLink, type RouteLinkProps, type RouteLocale, type RouteLocaleRef, type RouteMeta, type RoutePath, type RoutePathRef, type Routes, type RoutesRef, type SiteDataRef, type SiteLocaleDataRef, type UpdateHead, clientDataSymbol, defineClientConfig, resolveRoute, resolveRouteFullPath, resolveRoutePath, resolvers, updateHeadSymbol, useClientData, useLayouts, usePageComponent, usePageData, usePageFrontmatter, usePageHead, usePageLang, usePageLayout, useRedirects, useRouteLocale, useRoutePath, useRoutes, useSiteData, useSiteLocaleData, useUpdateHead, withBase };
