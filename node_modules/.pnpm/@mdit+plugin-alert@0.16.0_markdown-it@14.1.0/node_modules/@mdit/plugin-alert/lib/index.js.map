{"version":3,"file":"index.js","sources":["../src/plugins.ts"],"sourcesContent":["import type { PluginWithOptions } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\n\nimport type { MarkdownItAlertOptions } from \"./options.js\";\n\nconst HINT_REGEXP = /^>(?:(?: {0,3})| {0,2}\\t {0,1})\\[!(.*)\\]\\s*$/i;\n\nexport const alert: PluginWithOptions<MarkdownItAlertOptions> = (\n  md,\n  {\n    alertNames = [\"tip\", \"warning\", \"caution\", \"important\", \"note\"],\n    deep = false,\n    openRender,\n    closeRender,\n    titleRender,\n  } = {},\n) => {\n  const alertRule: RuleBlock = (state, startLine, endLine, silent) => {\n    if (\n      // if it's indented more than 3 spaces, it should be a code block\n      state.sCount[startLine] - state.blkIndent >= 4 ||\n      // check whether it's at first level\n      (state.level !== 0 && !deep)\n    )\n      return false;\n\n    const pos = state.bMarks[startLine] + state.tShift[startLine];\n    const max = state.eMarks[startLine];\n\n    // check the block quote marker\n    if (state.src.charAt(pos) !== \">\") return false;\n\n    // check alert markers\n    const match = HINT_REGEXP.exec(state.src.slice(pos, max));\n\n    if (!match || !alertNames.includes(match[1].toLowerCase())) return false;\n\n    // we know that it's going to be a valid alert,\n    // so no point trying to find the end of it in silent mode\n    if (silent) return true;\n\n    const type = match[1].toLowerCase();\n    const oldBMarks = [];\n    const oldBSCount = [];\n    const oldSCount = [];\n    const oldTShift = [];\n    const oldLineMax = state.lineMax;\n    const oldParentType = state.parentType;\n    const terminatorRules = state.md.block.ruler.getRules(\"alert\");\n\n    // @ts-expect-error: We are creating a new type called \"alert\"\n    state.parentType = \"alert\";\n\n    // Search the end of the block\n    //\n    // Block ends with either:\n    //  1. an empty line outside:\n    //     ```\n    //     > test\n    //\n    //     ```\n    //  2. an empty line inside:\n    //     ```\n    //     >\n    //     test\n    //     ```\n    //  3. another tag:\n    //     ```\n    //     > test\n    //      - - -\n    //     ```\n    let nextLine;\n\n    for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n      let adjustTab = false;\n      let lastLineEmpty = false;\n      let pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      const max = state.eMarks[nextLine];\n\n      // check if it's outdented, i.e. it's inside list item and indented\n      // less than said list item:\n      //\n      // ```\n      // 1. anything\n      //    > current blockquote\n      // 2. checking this line\n      // ```\n      const isOutdented = state.sCount[nextLine] < state.blkIndent;\n\n      if (pos >= max)\n        // Case 1: line is not inside the blockquote, and this line is empty.\n        break;\n\n      if (state.src.charAt(pos++) === \">\" && !isOutdented) {\n        let spaceAfterMarker: boolean;\n        // This line is inside the blockquote.\n\n        // set offset past spaces and \">\"\n        let initial = state.sCount[nextLine] + 1;\n\n        // skip one optional space after '>'\n        if (state.src.charAt(pos) === \" \") {\n          // ' >   test '\n          //     ^ -- position start of line here:\n          pos++;\n          initial++;\n          adjustTab = false;\n          spaceAfterMarker = true;\n        } else if (state.src.charAt(pos) === \"\\t\") {\n          spaceAfterMarker = true;\n\n          if ((state.bsCount[nextLine] + initial) % 4 === 3) {\n            // '  >\\t  test '\n            //       ^ -- position start of line here (tab has width===1)\n            pos++;\n            initial++;\n            adjustTab = false;\n          } else {\n            // ' >\\t  test '\n            //    ^ -- position start of line here + shift bsCount slightly\n            //         to make extra space appear\n            adjustTab = true;\n          }\n        } else {\n          spaceAfterMarker = false;\n        }\n\n        let offset = initial;\n\n        oldBMarks.push(state.bMarks[nextLine]);\n        state.bMarks[nextLine] = pos;\n\n        while (pos < max) {\n          const ch = state.src.charAt(pos);\n\n          if (ch === \"\\t\")\n            offset +=\n              4 -\n              ((offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4);\n          else if (ch === \" \") offset++;\n          else break;\n\n          pos++;\n        }\n\n        lastLineEmpty = pos >= max;\n\n        oldBSCount.push(state.bsCount[nextLine]);\n        state.bsCount[nextLine] =\n          state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] = offset - initial;\n\n        oldTShift.push(state.tShift[nextLine]);\n        state.tShift[nextLine] = pos - state.bMarks[nextLine];\n        continue;\n      }\n\n      // Case 2: line is not inside the blockquote, and the last line was empty.\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (lastLineEmpty) break;\n\n      // Case 3: another tag found.\n      let terminate = false;\n\n      for (const terminatorRule of terminatorRules)\n        if (terminatorRule(state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n\n      if (terminate) {\n        // Quirk to enforce \"hard termination mode\" for paragraphs;\n        // normally if you call `tokenize(state, startLine, nextLine)`,\n        // paragraphs will look below nextLine for paragraph continuation,\n        // but if blockquote is terminated by another tag, they shouldn't\n        state.lineMax = nextLine;\n\n        if (state.blkIndent !== 0) {\n          // state.blkIndent was non-zero, we now set it to zero,\n          // so we need to re-calculate all offsets to appear as\n          // if indent wasn't changed\n          oldBMarks.push(state.bMarks[nextLine]);\n          oldBSCount.push(state.bsCount[nextLine]);\n          oldTShift.push(state.tShift[nextLine]);\n          oldSCount.push(state.sCount[nextLine]);\n          state.sCount[nextLine] -= state.blkIndent;\n        }\n\n        break;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      oldBSCount.push(state.bsCount[nextLine]);\n      oldTShift.push(state.tShift[nextLine]);\n      oldSCount.push(state.sCount[nextLine]);\n\n      // A negative indentation means that this is a paragraph continuation\n      //\n      state.sCount[nextLine] = -1;\n    }\n\n    const oldIndent = state.blkIndent;\n\n    state.blkIndent = 0;\n\n    const titleLines: [number, number] = [startLine, startLine + 1];\n    const contentLines: [number, number] = [startLine + 1, 0];\n\n    const openToken = state.push(\"alert_open\", \"div\", 1);\n\n    openToken.markup = type;\n    openToken.attrJoin(\"class\", `markdown-alert markdown-alert-${type}`);\n    openToken.map = contentLines;\n\n    const titleToken = state.push(\"alert_title\", \"\", 0);\n\n    titleToken.attrJoin(\"class\", `markdown-alert-title`);\n    titleToken.markup = type;\n    titleToken.content = match[1];\n    titleToken.map = titleLines;\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    const closeToken = state.push(\"alert_close\", \"div\", -1);\n\n    closeToken.markup = type;\n\n    state.lineMax = oldLineMax;\n    state.parentType = oldParentType;\n    contentLines[1] = state.line;\n\n    // Restore original tShift; this might not be necessary since the parser\n    // has already been here, but just to make sure we can do that.\n    for (let i = 0; i < oldTShift.length; i++) {\n      state.bMarks[i + startLine] = oldBMarks[i];\n      state.tShift[i + startLine] = oldTShift[i];\n      state.sCount[i + startLine] = oldSCount[i];\n      state.bsCount[i + startLine] = oldBSCount[i];\n    }\n    state.blkIndent = oldIndent;\n\n    return true;\n  };\n\n  md.block.ruler.before(\"blockquote\", \"alert\", alertRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  if (openRender) md.renderer.rules.alert_open = openRender;\n  if (closeRender) md.renderer.rules.alert_close = closeRender;\n\n  md.renderer.rules.alert_title =\n    titleRender ??\n    ((tokens, index): string => {\n      const token = tokens[index];\n\n      return `<p class=\"markdown-alert-title\">${\n        token.content[0].toUpperCase() +\n        token.content.substring(1).toLowerCase()\n      }</p>\\n`;\n    });\n};\n"],"names":["HINT_REGEXP","alert","md","alertNames","deep","openRender","closeRender","titleRender","alertRule","state","startLine","endLine","silent","pos","max","match","type","oldBMarks","oldBSCount","oldSCount","oldTShift","oldLineMax","oldParentType","terminatorRules","nextLine","adjustTab","lastLineEmpty","isOutdented","spaceAfterMarker","initial","offset","ch","terminate","terminatorRule","oldIndent","titleLines","contentLines","openToken","titleToken","closeToken","i","tokens","index","token"],"mappings":"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"}