{"version":3,"file":"index.js","sources":["../../src/client/composables/useActiveHeaderLinks.ts"],"sourcesContent":["import { useDebounceFn, useEventListener } from '@vueuse/core'\nimport type { Router } from 'vuepress/client'\nimport { useRouter } from 'vuepress/client'\n\nexport interface UseActiveHeaderLinksOptions {\n  headerLinkSelector: string\n  headerAnchorSelector: string\n  delay: number\n  offset?: number\n}\n\n/**\n * Update current hash and do not trigger `scrollBehavior`\n */\nconst updateHash = async (router: Router, hash: string): Promise<void> => {\n  const { path, query } = router.currentRoute.value\n  const { scrollBehavior } = router.options\n\n  // temporarily disable `scrollBehavior`\n  router.options.scrollBehavior = undefined\n  await router.replace({ path, query, hash })\n  // restore it after navigation\n  router.options.scrollBehavior = scrollBehavior\n}\n\nexport const useActiveHeaderLinks = ({\n  headerLinkSelector,\n  headerAnchorSelector,\n  delay,\n  offset = 5,\n}: UseActiveHeaderLinksOptions): void => {\n  const router = useRouter()\n\n  const setActiveRouteHash = (): void => {\n    // get current scrollTop\n    const scrollTop = Math.max(\n      window.scrollY,\n      document.documentElement.scrollTop,\n      document.body.scrollTop,\n    )\n    // check if we are at page top\n    const isAtPageTop = Math.abs(scrollTop - 0) < offset\n\n    // replace current route hash with empty string when scrolling back to the top\n    if (isAtPageTop) {\n      void updateHash(router, '')\n\n      return\n    }\n\n    // get current scrollBottom\n    const scrollBottom = window.innerHeight + scrollTop\n    // get the total scroll length of current page\n    const scrollHeight = Math.max(\n      document.documentElement.scrollHeight,\n      document.body.scrollHeight,\n    )\n    // check if we have reached page bottom\n    // notice the `scrollBottom` might not be exactly equal to `scrollHeight`, so we add offset here\n    const isAtPageBottom = Math.abs(scrollHeight - scrollBottom) < offset\n\n    // get all header links\n    const headerLinks: HTMLAnchorElement[] = Array.from(\n      document.querySelectorAll(headerLinkSelector),\n    )\n    // get all header anchors\n    const headerAnchors: HTMLAnchorElement[] = Array.from(\n      document.querySelectorAll(headerAnchorSelector),\n    )\n    // filter anchors that do not have corresponding links\n    const existedHeaderAnchors = headerAnchors.filter((anchor) =>\n      headerLinks.some((link) => link.hash === anchor.hash),\n    )\n\n    for (let i = 0; i < existedHeaderAnchors.length; i++) {\n      const anchor = existedHeaderAnchors[i]\n      const nextAnchor = existedHeaderAnchors[i + 1] as\n        | HTMLAnchorElement\n        | undefined\n\n      // notice the `scrollTop` might not be exactly equal to `offsetTop` after clicking the anchor\n      // so we add offset\n\n      // if has scrolled past this anchor\n      const hasPassedCurrentAnchor =\n        scrollTop >= (anchor.parentElement?.offsetTop ?? 0) - offset\n\n      // if has not scrolled past next anchor\n      const hasNotPassedNextAnchor =\n        !nextAnchor ||\n        scrollTop < (nextAnchor.parentElement?.offsetTop ?? 0) - offset\n\n      // if this anchor is the active anchor\n      const isActive = hasPassedCurrentAnchor && hasNotPassedNextAnchor\n\n      // continue to find the active anchor\n      if (!isActive) continue\n\n      const routeHash = decodeURIComponent(router.currentRoute.value.hash)\n      const anchorHash = decodeURIComponent(anchor.hash)\n\n      // if the active anchor hash is current route hash, do nothing\n      if (routeHash === anchorHash) return\n\n      // check if anchor is at the bottom of the page to keep hash consistent\n      if (isAtPageBottom) {\n        for (let j = i + 1; j < existedHeaderAnchors.length; j++) {\n          // if current route hash is below the active hash, do nothing\n          if (routeHash === decodeURIComponent(existedHeaderAnchors[j].hash)) {\n            return\n          }\n        }\n      }\n\n      // replace current route hash with the active anchor hash\n      void updateHash(router, anchorHash)\n\n      return\n    }\n  }\n\n  useEventListener('scroll', useDebounceFn(setActiveRouteHash, delay))\n}\n"],"names":["updateHash","router","hash","path","query","scrollBehavior","useActiveHeaderLinks","headerLinkSelector","headerAnchorSelector","delay","offset","useRouter","useEventListener","useDebounceFn","scrollTop","scrollBottom","scrollHeight","isAtPageBottom","headerLinks","existedHeaderAnchors","anchor","link","i","nextAnchor","hasPassedCurrentAnchor","hasNotPassedNextAnchor","routeHash","anchorHash","j"],"mappings":"+GAcA,MAAMA,EAAa,MAAOC,EAAgBC,IAAgC,CACxE,KAAM,CAAE,KAAAC,EAAM,MAAAC,CAAM,EAAIH,EAAO,aAAa,MACtC,CAAE,eAAAI,CAAe,EAAIJ,EAAO,QAGlCA,EAAO,QAAQ,eAAiB,OAChC,MAAMA,EAAO,QAAQ,CAAE,KAAAE,EAAM,MAAAC,EAAO,KAAAF,CAAK,CAAC,EAE1CD,EAAO,QAAQ,eAAiBI,CAClC,EAEaC,EAAuB,CAAC,CACnC,mBAAAC,EACA,qBAAAC,EACA,MAAAC,EACA,OAAAC,EAAS,CACX,IAAyC,CACvC,MAAMT,EAASU,IA0FfC,EAAiB,SAAUC,EAxFA,IAAY,CAErC,MAAMC,EAAY,KAAK,IACrB,OAAO,QACP,SAAS,gBAAgB,UACzB,SAAS,KAAK,SAChB,EAKA,GAHoB,KAAK,IAAIA,EAAY,CAAC,EAAIJ,EAG7B,CACVV,EAAWC,EAAQ,EAAE,EAE1B,MACF,CAGA,MAAMc,EAAe,OAAO,YAAcD,EAEpCE,EAAe,KAAK,IACxB,SAAS,gBAAgB,aACzB,SAAS,KAAK,YAChB,EAGMC,EAAiB,KAAK,IAAID,EAAeD,CAAY,EAAIL,EAGzDQ,EAAmC,MAAM,KAC7C,SAAS,iBAAiBX,CAAkB,CAC9C,EAMMY,EAJqC,MAAM,KAC/C,SAAS,iBAAiBX,CAAoB,CAChD,EAE2C,OAAQY,GACjDF,EAAY,KAAMG,GAASA,EAAK,OAASD,EAAO,IAAI,CACtD,EAEA,QAASE,EAAI,EAAGA,EAAIH,EAAqB,OAAQG,IAAK,CACpD,MAAMF,EAASD,EAAqBG,CAAC,EAC/BC,EAAaJ,EAAqBG,EAAI,CAAC,EAQvCE,EACJV,IAAcM,EAAO,eAAe,WAAa,GAAKV,EAGlDe,EACJ,CAACF,GACDT,GAAaS,EAAW,eAAe,WAAa,GAAKb,EAM3D,GAAI,EAHac,GAA0BC,GAG5B,SAEf,MAAMC,EAAY,mBAAmBzB,EAAO,aAAa,MAAM,IAAI,EAC7D0B,EAAa,mBAAmBP,EAAO,IAAI,EAGjD,GAAIM,IAAcC,EAAY,OAG9B,GAAIV,GACF,QAASW,EAAIN,EAAI,EAAGM,EAAIT,EAAqB,OAAQS,IAEnD,GAAIF,IAAc,mBAAmBP,EAAqBS,CAAC,EAAE,IAAI,EAC/D,OAMD5B,EAAWC,EAAQ0B,CAAU,EAElC,MACF,CACF,EAE6DlB,CAAK,CAAC,CACrE"}