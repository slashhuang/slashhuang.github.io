---
title: 数组排序之冒泡、插入
id: 362
categories:
  - JavaScript算法
date: 2016-03-06 03:46:01
tags:
---

冒泡排序
<pre><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bubble_sort</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">temp</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="nx">temp</span> <span class="o">=</span> <span class="k">this</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
				<span class="k">this</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
				<span class="k">this</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="p">[</span><span class="mi">22</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">70</span><span class="p">];</span>
<span class="nx">num</span><span class="p">.</span><span class="nx">bubble_sort</span><span class="p">();</span></pre>
冒泡排序顾名思义就是一个个气泡不断往上浮动的意思。在JS的这段代码中就是不断将最大的数字排在数组尾部，然后类似数学归纳法一般，用同样的方式处理接下来的n-1个数字。这种算法需要计算(n-1)+(n-2)+...+1=(n-1)*n/2次，达到O(n*n)的级别。

插入排序
<div class="mw-highlight mw-content-ltr" dir="ltr">
<pre><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">insertion_sort</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">;</span>
	<span class="kd">var</span> <span class="nx">temp</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">temp</span> <span class="o">=</span> <span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">temp</span><span class="p">;</span> <span class="nx">j</span><span class="o">--</span><span class="p">)</span>
			<span class="k">this</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span>
		<span class="k">this</span><span class="p">[</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">};</span>
</pre>
</div>
插入排序对同样的数组进行排序就会表现的好一点，它的原理是在已经排序完成的数组基础上添加新数，从后往前进行比较并插入正确的位置。这种排序方式在最优的情况只需要计算n-1次(即原来的数列已经排序完成),在最差的情况需要计算1+2+...+(n-1)=n*(n-1)/2次，即平均复杂度为O(n*n)